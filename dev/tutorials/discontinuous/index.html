<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fitting a nonlinear discontinuous function · Sophon.jl</title><meta name="title" content="Fitting a nonlinear discontinuous function · Sophon.jl"/><meta property="og:title" content="Fitting a nonlinear discontinuous function · Sophon.jl"/><meta property="twitter:title" content="Fitting a nonlinear discontinuous function · Sophon.jl"/><meta name="description" content="Documentation for Sophon.jl."/><meta property="og:description" content="Documentation for Sophon.jl."/><meta property="twitter:description" content="Documentation for Sophon.jl."/><meta property="og:url" content="https://YichengDWu.github.io/Sophon.jl/tutorials/discontinuous/"/><meta property="twitter:url" content="https://YichengDWu.github.io/Sophon.jl/tutorials/discontinuous/"/><link rel="canonical" href="https://YichengDWu.github.io/Sophon.jl/tutorials/discontinuous/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Sophon.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ode/">Introduction with Lotka-Volterra System</a></li><li class="is-active"><a class="tocitem" href>Fitting a nonlinear discontinuous function</a><ul class="internal"><li><a class="tocitem" href="#Import-packages"><span>Import packages</span></a></li><li><a class="tocitem" href="#Dataset"><span>Dataset</span></a></li><li><a class="tocitem" href="#Naive-Neural-Networks"><span>Naive Neural Networks</span></a></li><li><a class="tocitem" href="#Siren"><span>Siren</span></a></li><li><a class="tocitem" href="#Gaussian-activation-function"><span>Gaussian activation function</span></a></li><li><a class="tocitem" href="#Quadratic-activation-function"><span>Quadratic activation function</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../poisson/">1D Multi-scale Poisson&#39;s Equation</a></li><li><a class="tocitem" href="../convection/">1D Convection Equation</a></li><li><a class="tocitem" href="../helmholtz/">2D Helmholtz Equation</a></li><li><a class="tocitem" href="../allen_cahn/">Allen-Cahn Equation with Sequential Training</a></li><li><a class="tocitem" href="../SchrödingerEquation/">Schrödinger Equation: A PDE System with Resampling</a></li><li><a class="tocitem" href="../L_shape/">Poisson equation over an L-shaped domain</a></li><li><a class="tocitem" href="../waveinverse2/">Inverse problem for the wave equation with unknown velocity field</a></li><li><a class="tocitem" href="../sod/">SOD Shock Tube Problem</a></li></ul></li><li><a class="tocitem" href="../../qa/">FAQ</a></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Fitting a nonlinear discontinuous function</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fitting a nonlinear discontinuous function</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/YichengDWu/Sophon.jl/blob/main/docs/src/tutorials/discontinuous.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fitting-a-nonlinear-discontinuous-function"><a class="docs-heading-anchor" href="#Fitting-a-nonlinear-discontinuous-function">Fitting a nonlinear discontinuous function</a><a id="Fitting-a-nonlinear-discontinuous-function-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-a-nonlinear-discontinuous-function" title="Permalink"></a></h1><p>This example is taken from <a href="https://royalsocietypublishing.org/doi/epdf/10.1098/rspa.2020.0334">here</a>. However, we do not use adaptive activation functions. Instead, we show that using suitable non-parametric activation functions immediately performs better.</p><p>Consider the following  discontinuous  function  with  discontinuity  at <span>$x=0$</span>:</p><p class="math-container">\[u(x)= \begin{cases}0.2 \sin (18 x) &amp; \text { if } x \leq 0 \\ 1+0.3 x \cos (54 x) &amp; \text { otherwise }\end{cases}\]</p><p>The domain is <span>$[-1,1]$</span>. The number of training points used is <code>50</code>.</p><h2 id="Import-packages"><a class="docs-heading-anchor" href="#Import-packages">Import packages</a><a id="Import-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Import-packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Lux, Sophon
using NNlib, Optimisers, Plots, Random, StatsBase, Zygote</code></pre><h2 id="Dataset"><a class="docs-heading-anchor" href="#Dataset">Dataset</a><a id="Dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset" title="Permalink"></a></h2><pre><code class="language-julia hljs">function u(x)
    if x &lt;= 0
        return 0.2 * sin(18 * x)
    else
        return 1 + 0.3 * x * cos(54 * x)
    end
end

function generate_data(n=50)
    x = reshape(collect(range(-1.0f0, 1.0f0, n)), (1, n))
    y = u.(x)
    return (x, y)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">generate_data (generic function with 2 methods)</code></pre><p>Let&#39;s visualize the data.</p><pre><code class="language-julia hljs">x_train, y_train = generate_data(50)
x_test, y_test = generate_data(200)
Plots.plot(vec(x_test), vec(y_test),label=false)</code></pre><p><img src="../u.svg" alt/></p><h2 id="Naive-Neural-Networks"><a class="docs-heading-anchor" href="#Naive-Neural-Networks">Naive Neural Networks</a><a id="Naive-Neural-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-Neural-Networks" title="Permalink"></a></h2><p>First, we demonstrate that naive, fully connected neural nets are not sufficient for fitting this function.</p><pre><code class="language-julia hljs">model = FullyConnected((1,50,50,50,50,1), relu)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chain(
    layer_1 = Dense(1 =&gt; 50, relu),     <span class="sgr90"># 100 parameters</span>
    layer_2 = Dense(50 =&gt; 50, relu),    <span class="sgr90"># 2_550 parameters</span>
    layer_3 = Dense(50 =&gt; 50, relu),    <span class="sgr90"># 2_550 parameters</span>
    layer_4 = Dense(50 =&gt; 50, relu),    <span class="sgr90"># 2_550 parameters</span>
    layer_5 = Dense(50 =&gt; 1),           <span class="sgr90"># 51 parameters</span>
) <span class="sgr90">        # Total: </span>7_801 parameters,
<span class="sgr90">          #        plus </span>0 states.</code></pre><h3 id="Train-the-model"><a class="docs-heading-anchor" href="#Train-the-model">Train the model</a><a id="Train-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Train-the-model" title="Permalink"></a></h3><pre><code class="language-julia hljs">function train(model, x, y)
    ps, st = Lux.setup(Random.default_rng(), model)
    opt = Adam()
    st_opt = Optimisers.setup(opt,ps)
    function loss(model, ps, st, x, y)
        y_pred, _ = model(x, ps, st)
        mes = mean(abs2, y_pred .- y)
        return mes
    end

    for i in 1:2000
        gs = gradient(p-&gt;loss(model,p,st,x,y), ps)[1]
        st_opt, ps = Optimisers.update(st_opt, ps, gs)
        if i % 100 == 1 || i == 2000
            println(&quot;Epoch $i ||  &quot;, loss(model,ps,st,x,y))
        end
    end
    return ps, st
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">train (generic function with 1 method)</code></pre><h3 id="Plot-the-result"><a class="docs-heading-anchor" href="#Plot-the-result">Plot the result</a><a id="Plot-the-result-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-result" title="Permalink"></a></h3><pre><code class="language-julia hljs">@time ps, st = train(model, x_train, y_train)
y_pred = model(x_test,ps,st)[1]
Plots.plot(vec(x_test), vec(y_pred),label=&quot;Prediction&quot;,line = (:dot, 4))
Plots.plot!(vec(x_test), vec(y_test),label=&quot;Exact&quot;,legend=:topleft)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Epoch 1 ||  0.35298327322484924
Epoch 101 ||  0.01625753644077361
Epoch 201 ||  0.015731190222969635
Epoch 301 ||  0.015511066697748517
Epoch 401 ||  0.014922663773394716
Epoch 501 ||  0.01334855651722185
Epoch 601 ||  0.01154377650865544
Epoch 701 ||  0.010315676540214097
Epoch 801 ||  0.009130916402607634
Epoch 901 ||  0.007950126822089603
Epoch 1001 ||  0.007545998593124739
Epoch 1101 ||  0.007389544216578381
Epoch 1201 ||  0.007324911967158221
Epoch 1301 ||  0.007338256421095142
Epoch 1401 ||  0.0072030004778013855
Epoch 1501 ||  0.00721385707362791
Epoch 1601 ||  0.007191937744796546
Epoch 1701 ||  0.007264969649612018
Epoch 1801 ||  0.0071496768584668954
Epoch 1901 ||  0.007119798778575408
Epoch 2000 ||  0.007154439911928925
  6.627595 seconds (10.97 M allocations: 1.317 GiB, 3.77% gc time, 92.65% compilation time)</code></pre><p><img src="../result1.svg" alt/></p><h2 id="Siren"><a class="docs-heading-anchor" href="#Siren">Siren</a><a id="Siren-1"></a><a class="docs-heading-anchor-permalink" href="#Siren" title="Permalink"></a></h2><p>We use four hidden layers with 50 neurons in each.</p><pre><code class="language-julia hljs">model = Siren(1,50,50,50,50,1; omega = 30f0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chain(
    layer_1 = Dense(1 =&gt; 50, sin),      <span class="sgr90"># 100 parameters</span>
    layer_2 = Dense(50 =&gt; 50, sin),     <span class="sgr90"># 2_550 parameters</span>
    layer_3 = Dense(50 =&gt; 50, sin),     <span class="sgr90"># 2_550 parameters</span>
    layer_4 = Dense(50 =&gt; 50, sin),     <span class="sgr90"># 2_550 parameters</span>
    layer_5 = Dense(50 =&gt; 1),           <span class="sgr90"># 51 parameters</span>
) <span class="sgr90">        # Total: </span>7_801 parameters,
<span class="sgr90">          #        plus </span>0 states.</code></pre><pre><code class="language-julia hljs">@time ps, st = train(model, x_train, y_train)
y_pred = model(x_test,ps,st)[1]
Plots.plot(vec(x_test), vec(y_pred),label=&quot;Prediction&quot;,line = (:dot, 4))
Plots.plot!(vec(x_test), vec(y_test),label=&quot;Exact&quot;,legend=:topleft)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Epoch 1 ||  1.6224736801744297
Epoch 101 ||  0.0013466102083493818
Epoch 201 ||  0.00020667056739168835
Epoch 301 ||  1.999367545587206e-5
Epoch 401 ||  8.893126438673999e-7
Epoch 501 ||  2.018972197248682e-8
Epoch 601 ||  2.9514464168830424e-10
Epoch 701 ||  6.402215010501814e-12
Epoch 801 ||  5.99227879926496e-13
Epoch 901 ||  1.5957472836940564e-13
Epoch 1001 ||  7.464175220900662e-14
Epoch 1101 ||  3.4587171197104595e-14
Epoch 1201 ||  4.3666045696167626e-14
Epoch 1301 ||  5.53436625178402e-14
Epoch 1401 ||  4.388667084410993e-14
Epoch 1501 ||  4.1782978533982995e-14
Epoch 1601 ||  7.562576197983836e-14
Epoch 1701 ||  3.505490545566065e-14
Epoch 1801 ||  5.1455660646456594e-14
Epoch 1901 ||  8.587558110582324e-14
Epoch 2000 ||  6.657088131799817e-14
  3.608021 seconds (7.20 M allocations: 1.216 GiB, 3.98% gc time, 81.36% compilation time)</code></pre><p><img src="../result.svg" alt/></p><p>As we can see the model overfits the data, and the high frequencies cannot be optimized away. We need to tunning the hyperparameter <code>omega</code></p><pre><code class="language-julia hljs">model = Siren(1,50,50,50,50,1; omega = 10f0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chain(
    layer_1 = Dense(1 =&gt; 50, sin),      <span class="sgr90"># 100 parameters</span>
    layer_2 = Dense(50 =&gt; 50, sin),     <span class="sgr90"># 2_550 parameters</span>
    layer_3 = Dense(50 =&gt; 50, sin),     <span class="sgr90"># 2_550 parameters</span>
    layer_4 = Dense(50 =&gt; 50, sin),     <span class="sgr90"># 2_550 parameters</span>
    layer_5 = Dense(50 =&gt; 1),           <span class="sgr90"># 51 parameters</span>
) <span class="sgr90">        # Total: </span>7_801 parameters,
<span class="sgr90">          #        plus </span>0 states.</code></pre><pre><code class="language-julia hljs">@time ps, st = train(model, x_train, y_train)
y_pred = model(x_test,ps,st)[1]
Plots.plot(vec(x_test), vec(y_pred),label=&quot;Prediction&quot;,line = (:dot, 4))
Plots.plot!(vec(x_test), vec(y_test),label=&quot;Exact&quot;,legend=:topleft)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Epoch 1 ||  0.720772809241818
Epoch 101 ||  0.00663950604271883
Epoch 201 ||  0.005313841758467077
Epoch 301 ||  0.004427724088769138
Epoch 401 ||  0.003570862876722669
Epoch 501 ||  0.002767245118820305
Epoch 601 ||  0.0020822545879486975
Epoch 701 ||  0.001516280794585087
Epoch 801 ||  0.0010015572749458319
Epoch 901 ||  0.0005655908866427492
Epoch 1001 ||  0.00027961262102985676
Epoch 1101 ||  0.00013999698405377066
Epoch 1201 ||  8.306481154436647e-5
Epoch 1301 ||  5.92965860778146e-5
Epoch 1401 ||  4.818714258181256e-5
Epoch 1501 ||  4.230653020758386e-5
Epoch 1601 ||  3.8769359933923094e-5
Epoch 1701 ||  3.636430648534046e-5
Epoch 1801 ||  3.453534928089617e-5
Epoch 1901 ||  3.301501496380151e-5
Epoch 2000 ||  3.166895436766311e-5
  0.519210 seconds (1.14 M allocations: 891.050 MiB, 6.81% gc time)</code></pre><p><img src="../result10.svg" alt/></p><h2 id="Gaussian-activation-function"><a class="docs-heading-anchor" href="#Gaussian-activation-function">Gaussian activation function</a><a id="Gaussian-activation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-activation-function" title="Permalink"></a></h2><p>We can also try using a fully connected net with the <a href="../../api/#Sophon.gaussian"><code>gaussian</code></a> activation function.</p><pre><code class="language-julia hljs">model = FullyConnected((1,50,50,50,50,1), gaussian)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chain(
    layer_1 = Dense(1 =&gt; 50, gaussian),  <span class="sgr90"># 100 parameters</span>
    layer_2 = Dense(50 =&gt; 50, gaussian),  <span class="sgr90"># 2_550 parameters</span>
    layer_3 = Dense(50 =&gt; 50, gaussian),  <span class="sgr90"># 2_550 parameters</span>
    layer_4 = Dense(50 =&gt; 50, gaussian),  <span class="sgr90"># 2_550 parameters</span>
    layer_5 = Dense(50 =&gt; 1),           <span class="sgr90"># 51 parameters</span>
) <span class="sgr90">        # Total: </span>7_801 parameters,
<span class="sgr90">          #        plus </span>0 states.</code></pre><pre><code class="language-julia hljs">@time ps, st = train(model, x_train, y_train)
y_pred = model(x_test,ps,st)[1]
Plots.plot(vec(x_test), vec(y_pred),label=&quot;Prediction&quot;,line = (:dot, 4))
Plots.plot!(vec(x_test), vec(y_test),label=&quot;Exact&quot;,legend=:topleft)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Epoch 1 ||  0.34893816449149206
Epoch 101 ||  0.005000192358235558
Epoch 201 ||  0.0036054995043452586
Epoch 301 ||  0.00038150301594514017
Epoch 401 ||  6.683734438909478e-6
Epoch 501 ||  4.9001331324907355e-6
Epoch 601 ||  1.3865218215988517e-6
Epoch 701 ||  2.8657517162299944e-5
Epoch 801 ||  1.9937787753736993e-7
Epoch 901 ||  0.00030108727676305346
Epoch 1001 ||  4.106814567455945e-8
Epoch 1101 ||  1.0673321889284127e-8
Epoch 1201 ||  2.854566270257816e-9
Epoch 1301 ||  6.771697915458985e-5
Epoch 1401 ||  2.0506444155151856e-9
Epoch 1501 ||  1.6263602564856576e-5
Epoch 1601 ||  1.1135998341832597e-6
Epoch 1701 ||  3.9201341542636946e-10
Epoch 1801 ||  2.5623055327004435e-6
Epoch 1901 ||  1.8094354003775263e-10
Epoch 2000 ||  1.7099979781174674e-11
  3.367074 seconds (6.34 M allocations: 1.170 GiB, 3.58% gc time, 81.25% compilation time)</code></pre><p><img src="../result2.svg" alt/></p><h2 id="Quadratic-activation-function"><a class="docs-heading-anchor" href="#Quadratic-activation-function">Quadratic activation function</a><a id="Quadratic-activation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-activation-function" title="Permalink"></a></h2><p><code>quadratic</code> is much cheaper to compute compared to the Gaussian activation function.</p><pre><code class="language-julia hljs">model = FullyConnected((1,50,50,50,50,1), quadratic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chain(
    layer_1 = Dense(1 =&gt; 50, quadratic),  <span class="sgr90"># 100 parameters</span>
    layer_2 = Dense(50 =&gt; 50, quadratic),  <span class="sgr90"># 2_550 parameters</span>
    layer_3 = Dense(50 =&gt; 50, quadratic),  <span class="sgr90"># 2_550 parameters</span>
    layer_4 = Dense(50 =&gt; 50, quadratic),  <span class="sgr90"># 2_550 parameters</span>
    layer_5 = Dense(50 =&gt; 1),           <span class="sgr90"># 51 parameters</span>
) <span class="sgr90">        # Total: </span>7_801 parameters,
<span class="sgr90">          #        plus </span>0 states.</code></pre><pre><code class="language-julia hljs">@time ps, st = train(model, x_train, y_train)
y_pred = model(x_test,ps,st)[1]
Plots.plot(vec(x_test), vec(y_pred),label=&quot;Prediction&quot;,line = (:dot, 4))
Plots.plot!(vec(x_test), vec(y_test),label=&quot;Exact&quot;,legend=:topleft)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Epoch 1 ||  0.27001936659558723
Epoch 101 ||  0.005572658967714106
Epoch 201 ||  0.004735762071370348
Epoch 301 ||  0.003998288930710362
Epoch 401 ||  0.0033307698224750767
Epoch 501 ||  0.0016337546853224922
Epoch 601 ||  0.0004075651566757858
Epoch 701 ||  5.862156917862021e-5
Epoch 801 ||  1.4155281751715152e-5
Epoch 901 ||  1.5090753826039012e-6
Epoch 1001 ||  1.6171855336412512e-5
Epoch 1101 ||  3.253622098538911e-7
Epoch 1201 ||  1.7438263651944966e-7
Epoch 1301 ||  1.2361299647804216e-6
Epoch 1401 ||  1.0352744789746405e-7
Epoch 1501 ||  4.253416382014182e-7
Epoch 1601 ||  4.343021982835373e-7
Epoch 1701 ||  2.1133959401329386e-7
Epoch 1801 ||  3.475949002094579e-7
Epoch 1901 ||  3.9009215124458454e-5
Epoch 2000 ||  1.4562402517141033e-5
  2.978514 seconds (6.06 M allocations: 1.152 GiB, 4.32% gc time, 83.38% compilation time)</code></pre><p><img src="../result3.svg" alt/></p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>&quot;Neural networks suppress high-frequency components&quot; is a misinterpretation of the spectral bias. The accurate way of putting it is that the lower frequencies in the error are optimized first in the optimization process. This can be seen in Siren&#39;s example of overfitting data, where you do not have implicit regularization. The high frequency in the network will never go away because it has fitted the data perfectly.</p><p>Mainstream attributes the phenomenon that neural networks &quot;suppress&quot; high frequencies to gradient descent. This is not the whole picture. Initialization also plays an important role. Siren mitigates this problem by initializing larger weights in the first layer. In contrast, activation functions such as Gaussian have sufficiently large gradients and sufficiently large support of the second derivative with proper hyperparameters. Please refer to [<a href="../../references/#sitzmann2020implicit">1</a>], [<a href="../../references/#ramasinghe2021beyond">2</a>] and [<a href="../../references/#ramasinghe2022regularizing">3</a>] if you want to dive deeper into this.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ode/">« Introduction with Lotka-Volterra System</a><a class="docs-footer-nextpage" href="../poisson/">1D Multi-scale Poisson&#39;s Equation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 19 December 2023 06:45">Tuesday 19 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
